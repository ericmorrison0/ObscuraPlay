# ObscuraPlay

ObscuraPlay is a privacy-first 9x9 grid game on Sepolia built with Zama FHEVM. Each player has an encrypted position on-chain, and only the player can decrypt their own coordinates through the Zama Relayer SDK. Players can optionally make their encrypted address publicly decryptable, enabling opt-in discovery without exposing private positions.

## Contents

- Overview
- Game Rules and Player Actions
- Privacy and Encryption Model
- Contract Interface
- Frontend Responsibilities
- Advantages
- Problems Solved
- Tech Stack
- Architecture and Data Flow
- Repository Structure
- Setup and Development
- Operational Constraints
- Limitations
- Future Plans
- License

## Overview

The project demonstrates how to build a location-based game where the main game state is encrypted on-chain. It combines:
- Fully homomorphic encryption (FHE) for private state storage and updates.
- Off-chain decryption via a relayer so only authorized users can read private data.
- A lightweight UI that visualizes the 9x9 grid without exposing private coordinates.

The game does not rely on mock data. All positions and updates are on-chain and encrypted, and the UI reads and writes real contract state.

## Game Rules and Player Actions

Map size and coordinates:
- The grid is 9 by 9.
- Valid coordinate range on both axes is 1 to 9.

Player actions:
- Join the game: The contract assigns a random encrypted (x, y) position.
- Decrypt my position: The player uses the relayer to decrypt their own coordinates.
- Make my address public: The player can make their encrypted address publicly decryptable.
- Jump to another tile: The player submits encrypted coordinates and a proof to move.

Movement rules:
- Inputs are encrypted and canonicalized on-chain.
- The contract applies modulo 9 and then adds 1, ensuring valid 1..9 coordinates.

## Privacy and Encryption Model

ObscuraPlay stores all positions as encrypted handles on-chain:
- Positions are euint8 values (encrypted integers).
- Player addresses can be stored as encrypted eaddress handles.
- Only the owner of a handle can decrypt it via the Zama Relayer SDK.
- The contract explicitly grants decryption permissions to the player and itself.
- A player can choose to make their encrypted address publicly decryptable.

No plaintext coordinates are stored on-chain. All decrypted values are computed off-chain by the relayer.

## Contract Interface

Core state and actions in `contracts/ObscuraPlay.sol`:
- `MAP_SIZE`: Fixed at 9.
- `join()`: Assigns a random encrypted position to the caller.
- `jump(externalEuint8, externalEuint8, bytes)`: Updates position using encrypted inputs.
- `makeMyAddressPublic()`: Marks the caller's encrypted address publicly decryptable.

View helpers:
- `hasJoined(address)`
- `getPlayerCount()`
- `getEncryptedPlayerAddressByIndex(uint256)`
- `getPlayerEncryptedAddress(address)`
- `getPlayerPosition(address)`

Events:
- `PlayerJoined`
- `PlayerMoved`
- `PlayerAddressMadePublic`

## Frontend Responsibilities

The frontend is in `app/` and is responsible for:
- Connecting wallets and displaying account state.
- Calling read methods with viem.
- Calling write methods with ethers.
- Running relayer decryption flows for player-owned encrypted data.
- Rendering a 9x9 grid UI based on decrypted coordinates.

The UI must use the ABI generated by the contract deployment:
- ABI source of truth: `deployments/sepolia`.
- The provided sync script copies the ABI into the frontend.

## Advantages

- Privacy by default: Positions are encrypted on-chain and never revealed in plaintext.
- Opt-in transparency: Players can make their encrypted address publicly decryptable.
- Fairness: Random spawn coordinates come from FHE randomness.
- On-chain integrity: Movement and state updates are enforced by smart contracts.
- Composable design: The encrypted address list can support future gameplay features.

## Problems Solved

- Prevents public tracking of player locations on-chain.
- Avoids server-side custody of sensitive player state.
- Keeps gameplay transparent and verifiable while protecting private data.
- Demonstrates practical FHEVM usage for interactive games, not just static data.

## Tech Stack

Smart contracts and tooling:
- Solidity 0.8.x
- Hardhat
- @fhevm/solidity and @fhevm/hardhat-plugin
- TypeChain and Ethers v6

Frontend:
- React + Vite
- viem for contract reads
- ethers for contract writes
- rainbowkit for wallet UI

Relayer:
- @zama-fhe/relayer-sdk

## Architecture and Data Flow

1. Player connects a wallet in the frontend.
2. Player joins the game by calling `join()`.
3. The contract assigns encrypted coordinates and allows the player to decrypt.
4. The frontend uses the relayer to decrypt the encrypted coordinates.
5. The UI renders the player on the 9x9 grid.
6. For movement, the frontend encrypts target coordinates and calls `jump()`.
7. The contract updates the encrypted position and emits an event.

## Repository Structure

```
ObscuraPlay/
├── app/                 # Frontend (React + Vite)
├── contracts/           # Solidity contracts
├── deploy/              # Deployment scripts
├── docs/                # Zama reference docs
├── scripts/             # Utility scripts (ABI sync)
├── tasks/               # Hardhat custom tasks
├── test/                # Contract tests
└── hardhat.config.ts    # Hardhat configuration
```

## Setup and Development

### Prerequisites

- Node.js 20+
- npm 7+
- A funded Sepolia account for deployment

### Install dependencies

Root dependencies:

```bash
npm install --no-package-lock
```

Frontend dependencies:

```bash
cd app
npm install --no-package-lock
```

### Environment configuration (root only)

Create a `.env` file in the repository root with:
- `INFURA_API_KEY`
- `PRIVATE_KEY` (must be a private key, not a mnemonic)
- `ETHERSCAN_API_KEY` (optional, for verification)

The frontend does not read environment variables.

### Compile and test

```bash
npm run compile
npm run test
```

Optional Sepolia test run:

```bash
npm run test:sepolia
```

### Local chain and deployment (contracts only)

```bash
npm run chain
npm run deploy:localhost
```

The frontend is not intended to connect to a localhost network.

### Deploy to Sepolia

```bash
npm run deploy:sepolia
```

Sync the ABI and deployment info into the frontend:

```bash
node scripts/sync-frontend-contract.mjs
```

Optional contract verification:

```bash
npm run verify:sepolia -- <CONTRACT_ADDRESS>
```

### Run the frontend

```bash
cd app
npm run dev
```

## Operational Constraints

These are non-negotiable project rules:
- Do not use Tailwind CSS.
- The frontend must use the ABI generated in `deployments/sepolia`.
- Contract writes use ethers; contract reads use viem.
- Do not use localhost networks in the frontend.
- Do not use localStorage in the frontend.
- Do not use JSON files in the frontend.
- The frontend must not use environment variables.
- Do not modify files in `app/hooks/`.
- Do not modify any `package.json` files or `.gitignore` without explicit approval.
- Do not use mnemonic-based deployment. Use `PRIVATE_KEY`.

## Limitations

- The map size is fixed at 9x9.
- The contract currently tracks only positions and encrypted addresses.
- There is no scoring, combat, or multi-player interaction beyond presence.
- Decryption is off-chain and requires the relayer SDK.

## Future Plans

- Add multi-player interaction mechanics (e.g., proximity events).
- Expand map size and support dynamic map configurations.
- Add player metadata with encrypted on-chain storage.
- Improve UI visualization and in-game feedback loops.
- Introduce public leaderboards derived from opt-in disclosures.

## License

BSD-3-Clause-Clear. See `LICENSE` for details.
